=begin
SimplyRETS API

The SimplyRETS API is an exciting step towards making it easier for\ndevelopers and real estate agents to build something awesome with\nreal estate data!\n\nThe documentation below makes live requests to our API using the\ntrial data. To get set up with the API using live MLS data, you\nmust have RETS credentials from your MLS, which you can then use to\ncreate an app with SimplyRETS. For more information on that\nprocess, please see our [FAQ](https://simplyrets.com/faq), [Getting\nStarted](https://simplyrets.com/blog/getting-set-up.html) page, or\n[contact us](https://simplyrets.com/\\#home-contact).\n\nBelow you'll find the API endpoints, query parameters, response bodies,\nand other information about using the SimplyRETS API. You can run\nqueries by clicking the 'Try it Out' button at the bottom of each\nsection.\n\n### Authentication\nThe SimplyRETS API uses Basic Authentication. When you create an\napp, you'll get a set of API credentials to access your\nlistings. If you're trying out the test data, you can use\n`simplyrets:simplyrets` for connecting to the API.\n\n### Media Types\nThe SimplyRETS API uses the 'Accept' header to allow clients to\ncontrol media types (content versions). We maintain backwards\ncompatibility with API clients by allowing them to specify a\ncontent version. We highly recommend setting and explicity media\ntype when your application reaches production. Both the structure\nand content of our API response bodies is subject to change so we\ncan add new features while respecting the stability of applications\nwhich have already been developed.\n\nTo always use the latest SimplyRETS content version, simply use\n`application/json` in your application `Accept` header.\n\nIf you want to pin your clients media type to a specific version,\nyou can use the vendor-specific SimplyRETS media type, e.g.\n`application/vnd.simplyrets-v0.1+json\"`\n\nTo view all valid content-types for making an `OPTIONS`, make a\nrequest to the SimplyRETS api root\n\n`curl -XOPTIONS -u simplyrets:simplyrets https://api.simplyrets.com/`\n\nThe default media types used in our API responses may change in the\nfuture. If you're building an application and care about the\nstability of the API, be sure to request a specific media type in the\nAccept header as shown in the examples below.\n\nThe wordpress plugin automatically sets the `Accept` header for the\ncompatible SimplyRETS media types.\n\n### Pagination\nThere a few pieces of useful information about each request stored\nin the HTTP Headers:\n\n- `X-Total-Count` shows you the total amount of listings that match\n  your current query.\n- `Link` contains pre-built pagination links for accessing the next\n'page' of listings that match your query. Read more about that\n[here](https://simplyrets.com/blog/api-pagination.html).\n

OpenAPI spec version: 1.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git


=end

require 'date'

module SimplyRetsClient
  # RETS MLS Listing Property
  class Listing
    # Agent only remarks
    attr_accessor :private_remarks

    # Specific property data associated with listing.
    attr_accessor :property

    # A unique identifier for this listing specific to the\nSimplyRETS API. Thie identifier is specific to the\nSimplyRETS api and has no correlation with the MLS\nnumber. Use this id when making requests to the single\nlisting endpoint (eg, `/properties/{mlsId}`).\n\nApplications should not rely on specific 'mlsId's being\npresent. Instead, apps should dynamically use the 'mlsId'\nafter using other more general query parameters. Many mls\nvendors require listings which are expired, terminated or\nsold to be purged, which will render calls to specific\nmlsId's to return nothing (or possibly a 404).\n
    attr_accessor :mls_id

    # Public instructions for showing the property.
    attr_accessor :showing_instructions

    # Listing office or brokerage.
    attr_accessor :office

    # Represents the length of the lease.
    attr_accessor :lease_term

    # Data accuracy disclaimer. The value in the disclaimer may\nchange depending on your MLS vendors rules.\n
    attr_accessor :disclaimer

    # Comprehensive property address information
    attr_accessor :address

    # Date and time the listing became Active
    attr_accessor :list_date

    # Comprehensive listing agent information
    attr_accessor :agent

    # Date and time of the last modification
    attr_accessor :modified

    # Comprehensive school zone data
    attr_accessor :school

    # Photos of the property. Images are served over https and are\nsuitable for production use on secure websites\n
    attr_accessor :photos

    # Price of the listing
    attr_accessor :list_price

    # Data Dictionary v1.3 ListingId. The well known identifier\nfor the listing. The value is the id or number by the MLS as\na public identifier for the listing.\n\nThis identifier should not be confused with the 'mlsId', which is\nspecific to the SimplyRETS API.\n
    attr_accessor :listing_id

    # MLS vendor information and data
    attr_accessor :mls

    # Geographic data for the listing
    attr_accessor :geo

    # Associate tax data
    attr_accessor :tax

    # Sales data
    attr_accessor :sales

    # Information about the status of the existing lease on the property.
    attr_accessor :lease_type

    # Description or remarks
    attr_accessor :remarks

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'private_remarks' => :'privateRemarks',
        :'property' => :'property',
        :'mls_id' => :'mlsId',
        :'showing_instructions' => :'showingInstructions',
        :'office' => :'office',
        :'lease_term' => :'leaseTerm',
        :'disclaimer' => :'disclaimer',
        :'address' => :'address',
        :'list_date' => :'listDate',
        :'agent' => :'agent',
        :'modified' => :'modified',
        :'school' => :'school',
        :'photos' => :'photos',
        :'list_price' => :'listPrice',
        :'listing_id' => :'listingId',
        :'mls' => :'mls',
        :'geo' => :'geo',
        :'tax' => :'tax',
        :'sales' => :'sales',
        :'lease_type' => :'leaseType',
        :'remarks' => :'remarks'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'private_remarks' => :'String',
        :'property' => :'Property',
        :'mls_id' => :'Integer',
        :'showing_instructions' => :'String',
        :'office' => :'Office',
        :'lease_term' => :'String',
        :'disclaimer' => :'String',
        :'address' => :'StreetAddress',
        :'list_date' => :'DateTime',
        :'agent' => :'Agent',
        :'modified' => :'DateTime',
        :'school' => :'School',
        :'photos' => :'Array<String>',
        :'list_price' => :'Float',
        :'listing_id' => :'String',
        :'mls' => :'MlsInformation',
        :'geo' => :'GeographicData',
        :'tax' => :'Tax',
        :'sales' => :'Sales',
        :'lease_type' => :'String',
        :'remarks' => :'String'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes[:'privateRemarks']
        self.private_remarks = attributes[:'privateRemarks']
      end
      if attributes[:'property']
        self.property = attributes[:'property']
      end
      if attributes[:'mlsId']
        self.mls_id = attributes[:'mlsId']
      else
        self.mls_id = 329479823
      end
      if attributes[:'showingInstructions']
        self.showing_instructions = attributes[:'showingInstructions']
      end
      if attributes[:'office']
        self.office = attributes[:'office']
      end
      if attributes[:'leaseTerm']
        self.lease_term = attributes[:'leaseTerm']
      end
      if attributes[:'disclaimer']
        self.disclaimer = attributes[:'disclaimer']
      end
      if attributes[:'address']
        self.address = attributes[:'address']
      end
      if attributes[:'listDate']
        self.list_date = attributes[:'listDate']
      end
      if attributes[:'agent']
        self.agent = attributes[:'agent']
      end
      if attributes[:'modified']
        self.modified = attributes[:'modified']
      end
      if attributes[:'school']
        self.school = attributes[:'school']
      end
      if attributes[:'photos']
        if (value = attributes[:'photos']).is_a?(Array)
          self.photos = value
        end
      end
      if attributes[:'listPrice']
        self.list_price = attributes[:'listPrice']
      end
      if attributes[:'listingId']
        self.listing_id = attributes[:'listingId']
      end
      if attributes[:'mls']
        self.mls = attributes[:'mls']
      end
      if attributes[:'geo']
        self.geo = attributes[:'geo']
      end
      if attributes[:'tax']
        self.tax = attributes[:'tax']
      end
      if attributes[:'sales']
        self.sales = attributes[:'sales']
      end
      if attributes[:'leaseType']
        self.lease_type = attributes[:'leaseType']
      end
      if attributes[:'remarks']
        self.remarks = attributes[:'remarks']
      end
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          private_remarks == o.private_remarks &&
          property == o.property &&
          mls_id == o.mls_id &&
          showing_instructions == o.showing_instructions &&
          office == o.office &&
          lease_term == o.lease_term &&
          disclaimer == o.disclaimer &&
          address == o.address &&
          list_date == o.list_date &&
          agent == o.agent &&
          modified == o.modified &&
          school == o.school &&
          photos == o.photos &&
          list_price == o.list_price &&
          listing_id == o.listing_id &&
          mls == o.mls &&
          geo == o.geo &&
          tax == o.tax &&
          sales == o.sales &&
          lease_type == o.lease_type &&
          remarks == o.remarks
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [private_remarks, property, mls_id, showing_instructions, office, lease_term, disclaimer, address, list_date, agent, modified, school, photos, list_price, listing_id, mls, geo, tax, sales, lease_type, remarks].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /^(true|t|yes|y|1)$/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = SimplyRetsClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end
end
