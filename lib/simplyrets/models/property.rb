=begin
SimplyRETS API

The SimplyRETS API is an exciting step towards making it easier for developers and real estate agents to build something awesome with real estate data!  The documentation below makes live requests to our API using the trial data. To get set up with the API using live MLS data, you must have RETS credentials from your MLS, which you can then use to create an app with SimplyRETS. For more information on that process, please see our [FAQ](https://simplyrets.com/faq), [Getting Started](https://simplyrets.com/blog/getting-set-up.html) page, or [contact us](https://simplyrets.com/\\#home-contact).  Below you'll find the API endpoints, query parameters, response bodies, and other information about using the SimplyRETS API. You can run queries by clicking the 'Try it Out' button at the bottom of each section.  ### Authentication The SimplyRETS API uses Basic Authentication. When you create an app, you'll get a set of API credentials to access your listings. If you're trying out the test data, you can use `simplyrets:simplyrets` for connecting to the API.  ### Media Types The SimplyRETS API uses the `Accept` header to allow clients to control media types (content versions). We maintain backwards compatibility with API clients by allowing them to specify a content version. We highly recommend setting and explicity media type when your application reaches production. Both the structure and content of our API response bodies is subject to change so we can add new features while respecting the stability of applications which have already been developed.  To always use the latest SimplyRETS content version, simply use `application/json` in your application `Accept` header.  If you want to pin your clients media type to a specific version, you can use the vendor-specific SimplyRETS media type, e.g. `application/vnd.simplyrets-v0.1+json\"`  To view all valid content-types for making an `OPTIONS`, make a request to the SimplyRETS api root  `curl -XOPTIONS -u simplyrets:simplyrets https://api.simplyrets.com/`  The default media types used in our API responses may change in the future. If you're building an application and care about the stability of the API, be sure to request a specific media type in the Accept header as shown in the examples below.  The wordpress plugin automatically sets the `Accept` header for the compatible SimplyRETS media types.  ### Pagination There a few pieces of useful information about each request stored in the HTTP Headers:  - `X-Total-Count` shows you the total amount of listings that match   your current query. - `Link` contains pre-built pagination links for accessing the next 'page' of listings that match your query. Read more about that [here](https://simplyrets.com/blog/api-pagination.html).

OpenAPI spec version: 1.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=end

require 'date'

module SimplyRetsClient
  # Rets MLS Listing Property
  class Property
    # Property roof description
    attr_accessor :roof

    # A description of the cooling or air conditioning features of the property.
    attr_accessor :cooling

    # Property style description or short string
    attr_accessor :style

    # Square footage of the building associated with a listing
    attr_accessor :area

    # Number of full bathrooms
    attr_accessor :baths_full

    # Number of half bathrooms
    attr_accessor :baths_half

    # Number of stories or levels. Represented as a `double' to account for half stories.
    attr_accessor :stories

    # Number of fireplaces
    attr_accessor :fireplaces

    # The type(s) of flooring found within the property.
    attr_accessor :flooring

    # Heating description or short string
    attr_accessor :heating

    attr_accessor :foundation

    attr_accessor :pool_features

    attr_accessor :laundry_features

    attr_accessor :occupant_name

    attr_accessor :lot_description

    # Lot size in acres  **Added on 2016/05/04 - Not available for all RETS vendors**
    attr_accessor :lot_size_acres

    # The property's sub-type, i.e. SingleFamilyResidential, Condo, etc. Or a list of Sub Types for Mobile, such as Expando, Manufactured, Modular, etc.
    attr_accessor :sub_type

    # Number of bedrooms
    attr_accessor :bedrooms

    # The properties interior features
    attr_accessor :interior_features

    # Lot size dimensions or square footage as a text. This field is generally used to show the pretty formatted lot size.
    attr_accessor :lot_size

    attr_accessor :area_source

    # Yearly maintenance expense
    attr_accessor :maintenance_expense

    # Additional room information
    attr_accessor :additional_rooms

    # Exterior Features for the listing
    attr_accessor :exterior_features

    # Water description and details
    attr_accessor :water

    # View details and description
    attr_accessor :view

    # The total area of the lot.  See `lotSizeUnits` for the units of measurement (Square Feet, Square Meters, Acres, etc.).  **Added on 2016/05/04 - Not available for all RETS vendors**
    attr_accessor :lot_size_area

    # The subdivision or community name
    attr_accessor :subdivision

    # The materials that were used in the construction of the property.
    attr_accessor :construction

    attr_accessor :parking

    # Unit of measurement for the lotSizeArea field.  e.g. Square Feet, Square Meters, Acres, etc.  If this field is `null` the units is the default unit of measure specified by your RETS provider.  **Added on 2016/05/04 - Not available for all RETS vendors**
    attr_accessor :lot_size_area_units

    # Abbreviated property type. RES is Residential, CND is CondoOrTownhome, RNT is Rental, MLF is Multi-Family, CRE is Commercial, LND is Land, FRM is Farm. See the `propertySubType` field for more information.
    attr_accessor :type

    # Number of garage spaces
    attr_accessor :garage_spaces

    attr_accessor :accessibility

    attr_accessor :occupant_type

    # Year the property was built
    attr_accessor :year_built

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'roof' => :'roof',
        :'cooling' => :'cooling',
        :'style' => :'style',
        :'area' => :'area',
        :'baths_full' => :'bathsFull',
        :'baths_half' => :'bathsHalf',
        :'stories' => :'stories',
        :'fireplaces' => :'fireplaces',
        :'flooring' => :'flooring',
        :'heating' => :'heating',
        :'foundation' => :'foundation',
        :'pool_features' => :'poolFeatures',
        :'laundry_features' => :'laundryFeatures',
        :'occupant_name' => :'occupantName',
        :'lot_description' => :'lotDescription',
        :'lot_size_acres' => :'lotSizeAcres',
        :'sub_type' => :'subType',
        :'bedrooms' => :'bedrooms',
        :'interior_features' => :'interiorFeatures',
        :'lot_size' => :'lotSize',
        :'area_source' => :'areaSource',
        :'maintenance_expense' => :'maintenanceExpense',
        :'additional_rooms' => :'additionalRooms',
        :'exterior_features' => :'exteriorFeatures',
        :'water' => :'water',
        :'view' => :'view',
        :'lot_size_area' => :'lotSizeArea',
        :'subdivision' => :'subdivision',
        :'construction' => :'construction',
        :'parking' => :'parking',
        :'lot_size_area_units' => :'lotSizeAreaUnits',
        :'type' => :'type',
        :'garage_spaces' => :'garageSpaces',
        :'accessibility' => :'accessibility',
        :'occupant_type' => :'occupantType',
        :'year_built' => :'yearBuilt'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'roof' => :'String',
        :'cooling' => :'String',
        :'style' => :'String',
        :'area' => :'Integer',
        :'baths_full' => :'Integer',
        :'baths_half' => :'Integer',
        :'stories' => :'Float',
        :'fireplaces' => :'Integer',
        :'flooring' => :'String',
        :'heating' => :'String',
        :'foundation' => :'String',
        :'pool_features' => :'String',
        :'laundry_features' => :'String',
        :'occupant_name' => :'String',
        :'lot_description' => :'String',
        :'lot_size_acres' => :'Float',
        :'sub_type' => :'String',
        :'bedrooms' => :'Integer',
        :'interior_features' => :'String',
        :'lot_size' => :'String',
        :'area_source' => :'String',
        :'maintenance_expense' => :'Float',
        :'additional_rooms' => :'String',
        :'exterior_features' => :'String',
        :'water' => :'String',
        :'view' => :'String',
        :'lot_size_area' => :'Float',
        :'subdivision' => :'String',
        :'construction' => :'String',
        :'parking' => :'Parking',
        :'lot_size_area_units' => :'String',
        :'type' => :'String',
        :'garage_spaces' => :'Float',
        :'accessibility' => :'String',
        :'occupant_type' => :'String',
        :'year_built' => :'Integer'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'roof')
        self.roof = attributes[:'roof']
      else
        self.roof = "Composition"
      end

      if attributes.has_key?(:'cooling')
        self.cooling = attributes[:'cooling']
      end

      if attributes.has_key?(:'style')
        self.style = attributes[:'style']
      else
        self.style = "Ranch, Traditional"
      end

      if attributes.has_key?(:'area')
        self.area = attributes[:'area']
      else
        self.area = 5984
      end

      if attributes.has_key?(:'bathsFull')
        self.baths_full = attributes[:'bathsFull']
      end

      if attributes.has_key?(:'bathsHalf')
        self.baths_half = attributes[:'bathsHalf']
      end

      if attributes.has_key?(:'stories')
        self.stories = attributes[:'stories']
      else
        self.stories = 2.0
      end

      if attributes.has_key?(:'fireplaces')
        self.fireplaces = attributes[:'fireplaces']
      else
        self.fireplaces = 1
      end

      if attributes.has_key?(:'flooring')
        self.flooring = attributes[:'flooring']
      end

      if attributes.has_key?(:'heating')
        self.heating = attributes[:'heating']
      else
        self.heating = "Central System, Forced Air, Gas"
      end

      if attributes.has_key?(:'foundation')
        self.foundation = attributes[:'foundation']
      end

      if attributes.has_key?(:'poolFeatures')
        self.pool_features = attributes[:'poolFeatures']
      end

      if attributes.has_key?(:'laundryFeatures')
        self.laundry_features = attributes[:'laundryFeatures']
      end

      if attributes.has_key?(:'occupantName')
        self.occupant_name = attributes[:'occupantName']
      end

      if attributes.has_key?(:'lotDescription')
        self.lot_description = attributes[:'lotDescription']
      end

      if attributes.has_key?(:'lotSizeAcres')
        self.lot_size_acres = attributes[:'lotSizeAcres']
      else
        self.lot_size_acres = 10.0
      end

      if attributes.has_key?(:'subType')
        self.sub_type = attributes[:'subType']
      end

      if attributes.has_key?(:'bedrooms')
        self.bedrooms = attributes[:'bedrooms']
      else
        self.bedrooms = 5
      end

      if attributes.has_key?(:'interiorFeatures')
        self.interior_features = attributes[:'interiorFeatures']
      else
        self.interior_features = "2-Story Foyer,9 ft + Ceil Main,Cathedral Ceiling,Double Vnty Other,High Speed Internet Available,Entrance Foyer,Hardwood Floors,Trey Ceilings,Walk-In Closet(s),Wall/Wall Carpet "
      end

      if attributes.has_key?(:'lotSize')
        self.lot_size = attributes[:'lotSize']
      else
        self.lot_size = "3/4 Up To 1 Acre"
      end

      if attributes.has_key?(:'areaSource')
        self.area_source = attributes[:'areaSource']
      else
        self.area_source = "Tax Record"
      end

      if attributes.has_key?(:'maintenanceExpense')
        self.maintenance_expense = attributes[:'maintenanceExpense']
      end

      if attributes.has_key?(:'additionalRooms')
        self.additional_rooms = attributes[:'additionalRooms']
      end

      if attributes.has_key?(:'exteriorFeatures')
        self.exterior_features = attributes[:'exteriorFeatures']
      else
        self.exterior_features = "1-2 Step Entry,Barn(s),Fenced Yard,Front Porch,Garden Area,Guest House,Out-Buildings,Patio,Prof Landscaping "
      end

      if attributes.has_key?(:'water')
        self.water = attributes[:'water']
      end

      if attributes.has_key?(:'view')
        self.view = attributes[:'view']
      end

      if attributes.has_key?(:'lotSizeArea')
        self.lot_size_area = attributes[:'lotSizeArea']
      else
        self.lot_size_area = 5000.0
      end

      if attributes.has_key?(:'subdivision')
        self.subdivision = attributes[:'subdivision']
      else
        self.subdivision = "River Oaks"
      end

      if attributes.has_key?(:'construction')
        self.construction = attributes[:'construction']
      end

      if attributes.has_key?(:'parking')
        self.parking = attributes[:'parking']
      end

      if attributes.has_key?(:'lotSizeAreaUnits')
        self.lot_size_area_units = attributes[:'lotSizeAreaUnits']
      else
        self.lot_size_area_units = "Sq Ft"
      end

      if attributes.has_key?(:'type')
        self.type = attributes[:'type']
      else
        self.type = "RES"
      end

      if attributes.has_key?(:'garageSpaces')
        self.garage_spaces = attributes[:'garageSpaces']
      end

      if attributes.has_key?(:'accessibility')
        self.accessibility = attributes[:'accessibility']
      end

      if attributes.has_key?(:'occupantType')
        self.occupant_type = attributes[:'occupantType']
      end

      if attributes.has_key?(:'yearBuilt')
        self.year_built = attributes[:'yearBuilt']
      else
        self.year_built = 2007
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properies with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      type_validator = EnumAttributeValidator.new('String', ["RES", "CND", "RNT", "MLF", "CRE", "LND", "FRM"])
      return false unless type_validator.valid?(@type)
      return true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] type Object to be assigned
    def type=(type)
      validator = EnumAttributeValidator.new('String', ["RES", "CND", "RNT", "MLF", "CRE", "LND", "FRM"])
      unless validator.valid?(type)
        fail ArgumentError, "invalid value for 'type', must be one of #{validator.allowable_values}."
      end
      @type = type
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          roof == o.roof &&
          cooling == o.cooling &&
          style == o.style &&
          area == o.area &&
          baths_full == o.baths_full &&
          baths_half == o.baths_half &&
          stories == o.stories &&
          fireplaces == o.fireplaces &&
          flooring == o.flooring &&
          heating == o.heating &&
          foundation == o.foundation &&
          pool_features == o.pool_features &&
          laundry_features == o.laundry_features &&
          occupant_name == o.occupant_name &&
          lot_description == o.lot_description &&
          lot_size_acres == o.lot_size_acres &&
          sub_type == o.sub_type &&
          bedrooms == o.bedrooms &&
          interior_features == o.interior_features &&
          lot_size == o.lot_size &&
          area_source == o.area_source &&
          maintenance_expense == o.maintenance_expense &&
          additional_rooms == o.additional_rooms &&
          exterior_features == o.exterior_features &&
          water == o.water &&
          view == o.view &&
          lot_size_area == o.lot_size_area &&
          subdivision == o.subdivision &&
          construction == o.construction &&
          parking == o.parking &&
          lot_size_area_units == o.lot_size_area_units &&
          type == o.type &&
          garage_spaces == o.garage_spaces &&
          accessibility == o.accessibility &&
          occupant_type == o.occupant_type &&
          year_built == o.year_built
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [roof, cooling, style, area, baths_full, baths_half, stories, fireplaces, flooring, heating, foundation, pool_features, laundry_features, occupant_name, lot_description, lot_size_acres, sub_type, bedrooms, interior_features, lot_size, area_source, maintenance_expense, additional_rooms, exterior_features, water, view, lot_size_area, subdivision, construction, parking, lot_size_area_units, type, garage_spaces, accessibility, occupant_type, year_built].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /^(true|t|yes|y|1)$/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = SimplyRetsClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
